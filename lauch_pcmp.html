<html>

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="content-type" content="text/html;charset=utf-8">

  <style type="text/css">
    html {
      line-height: 1.15;
      /* 1 */
      -webkit-text-size-adjust: 100%;
      /* 2 */
    }


    body {
      margin: 0;
    }


    main {
      display: block;
    }


    h1 {
      font-size: 2em;
      margin: 0.67em 0;
    }


    hr {
      box-sizing: content-box;
      /* 1 */
      height: 0;
      /* 1 */
      overflow: visible;
      /* 2 */
    }

    pre {
      font-family: monospace, monospace;
      /* 1 */
      font-size: 1em;
      /* 2 */
    }

    a {
      background-color: transparent;
    }

    abbr[title] {
      border-bottom: none;
      /* 1 */
      text-decoration: underline;
      /* 2 */
      text-decoration: underline dotted;
      /* 2 */
    }

    b,
    strong {
      font-weight: bolder;
    }

    code,
    kbd,
    samp {
      font-family: monospace, monospace;
      /* 1 */
      font-size: 1em;
      /* 2 */
    }


    small {
      font-size: 80%;
    }

    sub,
    sup {
      font-size: 75%;
      line-height: 0;
      position: relative;
      vertical-align: baseline;
    }

    sub {
      bottom: -0.25em;
    }

    sup {
      top: -0.5em;
    }

    img {
      border-style: none;
    }

    button,
    input,
    optgroup,
    select,
    textarea {
      font-family: inherit;
      /* 1 */
      font-size: 100%;
      /* 1 */
      line-height: 1.15;
      /* 1 */
      margin: 0;
      /* 2 */
    }

    button,
    input {
      /* 1 */
      overflow: visible;
    }

    button,
    select {
      /* 1 */
      text-transform: none;
    }

    button,
    [type="button"],
    [type="reset"],
    [type="submit"] {
      -webkit-appearance: button;
    }

    button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner {
      border-style: none;
      padding: 0;
    }

    button:-moz-focusring,
    [type="button"]:-moz-focusring,
    [type="reset"]:-moz-focusring,
    [type="submit"]:-moz-focusring {
      outline: 1px dotted ButtonText;
    }

    fieldset {
      padding: 0.35em 0.75em 0.625em;
    }

    legend {
      box-sizing: border-box;
      /* 1 */
      color: inherit;
      /* 2 */
      display: table;
      /* 1 */
      max-width: 100%;
      /* 1 */
      padding: 0;
      /* 3 */
      white-space: normal;
      /* 1 */
    }

    progress {
      vertical-align: baseline;
    }

    textarea {
      overflow: auto;
    }

    [type="checkbox"],
    [type="radio"] {
      box-sizing: border-box;
      /* 1 */
      padding: 0;
      /* 2 */
    }

    [type="number"]::-webkit-inner-spin-button,
    [type="number"]::-webkit-outer-spin-button {
      height: auto;
    }

    [type="search"] {
      -webkit-appearance: textfield;
      /* 1 */
      outline-offset: -2px;
      /* 2 */
    }

    [type="search"]::-webkit-search-decoration {
      -webkit-appearance: none;
    }

    ::-webkit-file-upload-button {
      -webkit-appearance: button;
      /* 1 */
      font: inherit;
      /* 2 */
    }

    details {
      display: block;
    }

    summary {
      display: list-item;
    }

    template {
      display: none;
    }

    [hidden] {
      display: none;
    }
  </style>

  <style>
    * {
      box-sizing: border-box;
    }

    img {
      border: none;
      overflow: hidden;
    }

    .flex-x-center {
      display: flex;
      justify-content: center;
    }

    .flex-center {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .flex-row {
      display: flex;
      flex-direction: row;
    }

    .flex-col {
      display: flex;
      flex-direction: column;
    }

    .flex-columns {
      display: flex;
      flex-direction: column;
    }

    .flex {
      display: flex;
    }

    .flex-first {
      order: -1;
    }

    .flex-last {
      order: 1;
    }

    .flex-items-top {
      align-items: flex-start;
    }

    .flex-items-middle {
      align-items: center;
    }

    .flex-items-bottom {
      align-items: flex-end;
    }

    .flex-top {
      align-self: flex-start;
    }

    .flex-middle {
      align-self: center;
    }

    .flex-bottom {
      align-self: flex-end;
    }

    .flex-items-left {
      justify-content: flex-start;
    }

    .flex-items-center {
      justify-content: center;
    }

    .flex-items-right {
      justify-content: flex-end;
    }

    .flex-items-around {
      justify-content: space-around;
    }

    .flex-items-between {
      justify-content: space-between;
    }
  </style>

  <script src="./editor/scene/js/utils.js"></script>
  <script src="./pc2d/output/pc2d-entry.js"></script>
  <script src="./workers/kvStorage.js"></script>
  <script src="./workers/localForageAdaptor.js"></script>
  <script>
  var trim;
if(String.prototype.trim){
    trim = function(str){ return str.trim(); };
}else{
    trim = function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); };
}	
function hash(_hash,replace){
    if(!arguments.length){
        return _getHash();
    }
    if(_hash.charAt(0) == "#"){
        _hash = _hash.substring(1);
    }
    if(replace){
        _replace(_hash);
    }else{
        location.hash = "#" + _hash;
    }
    return _hash;
}
function _getSegment(str, delimiter){
    var i = str.indexOf(delimiter);
    return (i >= 0) ? str.substring(i+1) : "";
}

function _getHash(){
    return _getSegment(location.href, "#");
}

function _replace(hash){
    var href = location.href.replace(/#.*/, "");
    location.replace(href + "#" + hash);
}

if("onhashchange" in window){

    var _oldonhashchange = window.onhashchange;
    window.onhashchange = function(){
        var eventObject = {"hash":_getHash()};
        var event = document.createEvent("HTMLEvents");
        event.initEvent('wc-hashchange', eventObject.bubbles, eventObject.cancelable, window, 1);


        Object.keys(eventObject).forEach(function(eventProperty) {
            if (!(eventProperty in {bubbles: 1, cancelable: 1})) {
                event[eventProperty] = eventObject[eventProperty];
            }
        });
        
        window.dispatchEvent(event);
        _oldonhashchange && _oldonhashchange.apply(window,arguments);
    }     
}
function fireRoute(params, currentPath, newPath){
    var queue, isStopped, isPrevented, eventObj, callbackArgs, i, l;

    queue = this.callbackQueue;
    isStopped = false;
    isPrevented = false;
    eventObj = {
        stopImmediatePropagation: function(){ isStopped = true; },
        preventDefault: function(){ isPrevented = true; },
        oldPath: currentPath,
        newPath: newPath,
        params: params
    };

    callbackArgs = [eventObj];

    if(params instanceof Array){
        callbackArgs = callbackArgs.concat(params);
    }else{
        for(var key in params){
            callbackArgs.push(params[key]);
        }
    }

    for(i=0, l=queue.length; i<l; ++i){
        if(!isStopped){
            queue[i].apply(null, callbackArgs);
        }
    }

    return !isPrevented;
}


function RouterBase(){
    this._routes = [];
    this._routeIndex = {};
    this._started =  false;
    this._currentPath =  "";

    this.idMatch =  /:(\w[\w\d]*)/g;
    this.idReplacement =  "([^\\/]+)";
    this.globMatch =  /\*(\w[\w\d]*)/;
    this.globReplacement =  "(.+)";

    ///^\/foo\?([^\/]+?)\/?$/i
}


RouterBase.prototype.register =  function(/*String|RegExp*/ route, /*Function*/ callback){
    return this._registerRoute(route, callback);
}


RouterBase.prototype._registerRoute =  function(route,callback,isBefore){
    var index, exists, routeObj, callbackQueue, removed,
        self = this, routes = this._routes,
        routeIndex = this._routeIndex;
    index = this._routeIndex[route];
    exists = typeof index !== "undefined";
    if(exists){
        routeObj = routes[index];
    }

    if(!routeObj){
        routeObj = {
            route: route,
            callbackQueue: [],
            fire: fireRoute
        };
    }

    callbackQueue = routeObj.callbackQueue;


    if(typeof route == "string"){
        routeObj.parameterNames = this._getParameterNames(route);
        routeObj.route = this._convertRouteToRegExp(route);
    }

    if(isBefore){
        callbackQueue.unshift(callback);
    }else{
        callbackQueue.push(callback);
    }

    if(!exists){
        index = routes.length;
        routeIndex[route] = index;
        routes.push(routeObj);
    }

    removed = false;

    return {
        remove: function(){
            var i, l;

            if(removed){ return; }

            for(i=0, l=callbackQueue.length; i<l; ++i){
                if(callbackQueue[i] === callback){
                    callbackQueue.splice(i, 1);
                }
            }


            if(callbackQueue.length === 0){
                routes.splice(index, 1);
                self._indexRoutes();
            }

            removed = true;
        },
        register: function(callback, isBefore){
            return self.register(route, callback, isBefore);
        }
    };
}

RouterBase.prototype._indexRoutes =  function(){
    var i, l, route, routeIndex, routes = this._routes;
    routeIndex = this._routeIndex = {};
    for(i=0, l=routes.length; i<l; ++i){
        route = routes[i];
        routeIndex[route.route] = i;
    }
}

RouterBase.prototype._convertRouteToRegExp =  function(route){
    route = route.replace(this.idMatch, this.idReplacement);
    route = route.replace(this.globMatch, this.globReplacement);
    route = "^" + route + "([^/]*?)" + "$";
    return new RegExp(route);
}

RouterBase.prototype._getParameterNames = function(route){
    var idMatch = this.idMatch,
        globMatch = this.globMatch,
        parameterNames = [], match;

    idMatch.lastIndex = 0;

    while((match = idMatch.exec(route)) !== null){
        parameterNames.push(match[1]);
    }
    if((match = globMatch.exec(route)) !== null){
        parameterNames.push(match[1]);
    }

    return parameterNames.length > 0 ? parameterNames : null;
}


RouterBase.prototype.go =  function(path, replace){
    var applyChange;
  
    if(typeof path !== "string"){return false;}
    
    path = trim(path);
    applyChange = this._handlePathChange(path,replace);
    

    // if(applyChange){
    //     hash(path, replace);
    // }
    return applyChange;
}

RouterBase.prototype._handlePathChange =  function(newPath,replace){
    var i, j, li, lj, routeObj, result,
        allowChange, parameterNames, params,
        routes = this._routes,
        currentPath = this._currentPath;

    if(!this._started || newPath === currentPath){ return allowChange; }

    allowChange = true;

    for(i=0, li=routes.length; i<li; ++i){
        routeObj = routes[i];

        result = routeObj.route.exec(newPath);


        if(result){
            if(routeObj.parameterNames){
                parameterNames = routeObj.parameterNames;
                params = {};

                for(j=0, lj=parameterNames.length; j<lj; ++j){
                    params[parameterNames[j]] = result[j+1];
                }
            }else{
                params = result.slice(1);
            }
            
            hash(newPath, replace); 
            allowChange = routeObj.fire(params, currentPath, newPath);
        }
    }
  

    if(allowChange){
        this._currentPath = newPath;
    }

    return allowChange;
}

RouterBase.prototype.startup = function(defaultPath){
    if(this._started){ return; }

    var self = this,
        startingPath = hash();

    this._started = true;
  
    function _hashchangeHandle(){
        arguments[0] = arguments[0].hash
        self._handlePathChange.apply(self, arguments);
    }

    this._hashchangeHandle = _hashchangeHandle;
    window.addEventListener("wc-hashchange", _hashchangeHandle);

    if(!startingPath){
        this.go(defaultPath, true);
    }else{
        this._handlePathChange(startingPath);
    }
}

RouterBase.prototype.destroy = function(){
    if(this._hashchangeHandle){
        window.removeEventListener("wc-hashchange", this._hashchangeHandle);
    } 			
    this._routes = null;
    this._routeIndex = null;
}

  </script>
</head>

<body>
  <div id="app"></div>
  <script>

    ASSET_PREFIX = "";
    SCRIPT_PREFIX = "";
    SCENE_PATH = "460569.json";
    CONTEXT_OPTIONS = {
      'antialias': true,
      'alpha': false,
      'preserveDrawingBuffer': false
    };
    SCRIPTS = [];
    CONFIG_FILENAME = "";


    var app = new pc2d.Application(document.getElementById("app"), {
      assetPrefix: window.ASSET_PREFIX || "",
      scriptPrefix: window.SCRIPT_PREFIX || "",
      scriptsOrder: window.SCRIPTS || []
    });

    var _sync = pc2d.Entity.prototype._sync;
    pc2d.Entity.prototype._sync = function () {
      var _defer = false;


      if ((this.root !== this) || !(this.root.name === "Untitled" && this.root._parent == null)) {
        this.dom = this.dom || document.createElement("div");
        this.dom.className = this.tags.list().join(" ");
        if (this.name !== "New Entity" && this.name !== "Untitled") this.dom.classList.add(this.name);

        if (this.dom.getAttribute("data-pc2d-asset-texture")) {
          var asset = editor.call("assets:get", this.dom.getAttribute("data-pc2d-asset-texture"));
          if (this.css && this.css.type === "image") {
            asset && this.dom.setAttribute("src", asset.get("file.url"));
          } else {
            this.dom.style.backgroundImage = "url(" + asset.get("file.url") + ")";
          }
        } else {
          this.dom.removeAttribute("src");
          if (this.css) {
            this.dom.style.backgroundImage = "";
          }
        }
        if ((this.dom && this.parent) && !this.dom.parentNode && (this.dom.parentNode !== this.parent.dom)) {
          if (this.parent.dom) {
            this.parent.dom.appendChild(this.dom);
          }
        }

        if (!this.enabled && !this.css) {
          this.dom && (this.dom.style.display = "none");
        }
      }

      if (!_defer) {
        return _sync.call(this);
      }


    }




    var response = {
      "application_properties": {
        fill_mode: "KEEP_ASPECT",
        height: 1280,
        libraries: [],
        loading_screen_script: null,
        preserve_drawing_buffer: false,
        resolution_mode: "FIXED",
        scripts: [],
        transparent_canvas: false,
        use_device_pixel_ratio: false,
        use_legacy_scripts: false,
        width: 720
      },
      assets: [

      ]
    };



    var props = response.application_properties;
    var scenes = response.scenes;
    var assets = response.assets;

    var query = location.href.getQuery();
    var projectId = query.projectId;
    var scenehandler = app.loader.getHandler("scene");
    var scenePromise = localforage.getItem("TWCacheEntities/" + projectId);
    function _loadedScenes(callback) {


      scenePromise.then(function (data) {
        var url = "scene";
        app.systems.script.preloading = true;
        var scene = scenehandler.open(url, data);
        try {

        } catch (e) {
          // pc2d.TemplateUtils.waitForTemplatesInScene(
          //     data,
          //     assets,
          //     function(data){
          //       debugger

          //     });
        }
        app.systems.script.preloading = false;

        app.loader.clearCache(url, "scene");

        app.loader.patch({
          resource: scene,
          type: "scene"
        }, app.assets);

        app.root.addChild(scene.root);


        if (callback) {
          callback(null, scene);
        }

      });
    };

    function blobToDataURL(blob, callback) {
      let a = new FileReader();
      a.onload = function (e) { callback(e.target.result); }
      a.readAsDataURL(blob);
    }

    function _loadAssets() {
      var filelistPromise = localforage.getItem("TWCacheFiles/" + projectId + "/FileList");
      return Promise.all([filelistPromise]).then(([filelist]) => {
        var assetslist = filelist.map(filename => {
          return filename.replace("TWCacheFiles/" + projectId + "/", "");
        });

        var assetsmeta = {};

        var assets = {};

        var assetsPromise = filelist.map(filename => {
          return localforage.getItem(filename).then(asset => {

            return new Promise(function (resolve) {
              if (asset.file instanceof Blob) {
                blobToDataURL(asset.file, function (fileurl) {
                  var file = {
                    filename: asset.file.name, hash: undefined, size: asset.file.size, url: fileurl,
                  };
                  asset.file = file;
                  assets[asset.id] = asset;
                  resolve(asset);
                })
              } else {
                if (asset.type !== "folder") {
                  assets[asset.id] = asset;
                }
                resolve(asset);
              }

            })
          })
        });

        return Promise.all(assetsPromise).then(_ => {
          return assets;

        });
      })
    }





    app._parseApplicationProperties(props, function (err) {

      _loadAssets().then(function (assets) {
        app._parseAssets(assets);
        app.preload(function (err) {
          if (err) {
            console.error(err);
          }

          _loadedScenes(function (err, scene) {
            if (err) {
              console.error(err);
            }
            app.autoRender = false;
            var Root = app.root.children[0];

            Root.children.forEach(page => {
              page.enabled = false;
            });
            app.start();

            app.render();

            app.fire("pc2dapp:ready", Root);
          });
        });
      });
    });

  </script>

  <script>
  
  
  var root$ = new Promise(function(resolve,reject){
    app.on("pc2dapp:ready",function(root){
        // root.children[0].enabled = true;
        // root.children[0].syncHierarchy();
        resolve(root);
    });    
});

var pages = ["pages/index/index"];
window.wcRouter = new RouterBase({});

var router = window.wcRouter;

pages.forEach((pagePath,idx) => {
  router.register("/" + pagePath, function(evt){
        var options = {};
        if(evt.params && evt.params.length){
            var _query = evt.params[0].substring(1);

            var vars, pair,result = {};
            var _vars = _query.split("&");
            _vars.forEach(function (item, index, arr) {
                pair = item.split("=");
                if(pair[0]){
                    result[pair[0]] = decodeURIComponent(pair[1]);
                }
               
            }, this);
            options.query = result;
        }
        
        try {
            if(router.lastRouteIndex !== undefined){

                root$.then(function(root){
                    if(root.children[router.lastRouteIndex]) {
                        root.children[router.lastRouteIndex].enabled = false;
                        root.children[router.lastRouteIndex].fire("onUnload",options);
                    }
                });
                //window.$router.apps[router.lastRouteIndex + 1].$options.onUnload[0](options);  
               
                
            }              
            router.lastRouteIndex = idx;

            root$.then(function(root){
                if(root.children[router.lastRouteIndex]) {
                    root.children[router.lastRouteIndex].enabled = true;
                    root.children[router.lastRouteIndex].syncHierarchy();
                    root.children[router.lastRouteIndex].fire("onReady",options);
                }
            });


            // window.$router.apps[idx + 1].$options.onLoad[0](options);
            // window.$router.apps[idx + 1].$options.onReady[0](options);
        }catch(e){
            console.log(e)
        }
     });
});
router.startup();
  
  
  </script>
</body>

</html>