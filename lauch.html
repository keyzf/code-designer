<html>
  <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <meta http-equiv="content-type" content="text/html;charset=utf-8">

      <style type="text/css">
        html {
    line-height: 1.15; /* 1 */
    -webkit-text-size-adjust: 100%; /* 2 */
    }
    
    
    body {
    margin: 0;
    }
    
    
    main {
    display: block;
    }
    
    
    h1 {
    font-size: 2em;
    margin: 0.67em 0;
    }
    
    
    hr {
    box-sizing: content-box; /* 1 */
    height: 0; /* 1 */
    overflow: visible; /* 2 */
    }
    
    pre {
    font-family: monospace, monospace; /* 1 */
    font-size: 1em; /* 2 */
    }
    
    a {
    background-color: transparent;
    }
    
    abbr[title] {
    border-bottom: none; /* 1 */
    text-decoration: underline; /* 2 */
    text-decoration: underline dotted; /* 2 */
    }
    
    b,
    strong {
    font-weight: bolder;
    }
    
    code,
    kbd,
    samp {
    font-family: monospace, monospace; /* 1 */
    font-size: 1em; /* 2 */
    }
    
    
    small {
    font-size: 80%;
    }
    
    sub,
    sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
    }
    
    sub {
    bottom: -0.25em;
    }
    
    sup {
    top: -0.5em;
    }
    
    img {
    border-style: none;
    }
    
    button,
    input,
    optgroup,
    select,
    textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 1 */
    line-height: 1.15; /* 1 */
    margin: 0; /* 2 */
    }
    
    button,
    input { /* 1 */
    overflow: visible;
    }
    
    button,
    select { /* 1 */
    text-transform: none;
    }
    
    button,
    [type="button"],
    [type="reset"],
    [type="submit"] {
    -webkit-appearance: button;
    }
    
    button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner {
    border-style: none;
    padding: 0;
    }
    
    button:-moz-focusring,
    [type="button"]:-moz-focusring,
    [type="reset"]:-moz-focusring,
    [type="submit"]:-moz-focusring {
    outline: 1px dotted ButtonText;
    }
    
    fieldset {
    padding: 0.35em 0.75em 0.625em;
    }
    
    legend {
    box-sizing: border-box; /* 1 */
    color: inherit; /* 2 */
    display: table; /* 1 */
    max-width: 100%; /* 1 */
    padding: 0; /* 3 */
    white-space: normal; /* 1 */
    }
    
    progress {
    vertical-align: baseline;
    }
    
    textarea {
    overflow: auto;
    }
    
    [type="checkbox"],
    [type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    }
    
    [type="number"]::-webkit-inner-spin-button,
    [type="number"]::-webkit-outer-spin-button {
    height: auto;
    }
    
    [type="search"] {
    -webkit-appearance: textfield; /* 1 */
    outline-offset: -2px; /* 2 */
    }
    
    [type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
    }
    
    ::-webkit-file-upload-button {
    -webkit-appearance: button; /* 1 */
    font: inherit; /* 2 */
    }
    
    details {
    display: block;
    }
    
    summary {
    display: list-item;
    }
    
    template {
    display: none;
    }
    
    [hidden] {
    display: none;
    }
    </style>
    
    <style>
    * {
      box-sizing: border-box;
    }
    
    img {
      border: none;
      overflow: hidden;
    }
    
    .flex-x-center {
      display: flex;
      justify-content: center;
    }
    
    .flex-center {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .flex-row {
      display: flex;
      flex-direction: row;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
    }
    .flex-columns {
      display: flex;
      flex-direction: column;
    }
    .flex {
      display: flex;
    }
    .flex-first {
      order: -1;
    }
    
    .flex-last {
      order: 1;
    }
    
    .flex-items-top {
      align-items: flex-start;
    }
    
    .flex-items-middle {
      align-items: center;
    }
    
    .flex-items-bottom {
      align-items: flex-end;
    }
    
    .flex-top {
      align-self: flex-start;
    }
    
    .flex-middle {
      align-self: center;
    }
    
    .flex-bottom {
      align-self: flex-end;
    }
    
    .flex-items-left {
      justify-content: flex-start;
    }
    
    .flex-items-center {
      justify-content: center;
    }
    
    .flex-items-right {
      justify-content: flex-end;
    }
    
    .flex-items-around {
      justify-content: space-around;
    }
    
    .flex-items-between {
      justify-content: space-between;
    }
    </style>
    
    <script src="./editor/scene/js/utils.js"></script>
    <script src="./pc2d/output/pc2d-entry.js"></script>
    <script src="./workers/kvStorage.js"></script>
    <script src="./workers/localForageAdaptor.js"></script>
  </head>
  <body>
      <div id="app"></div>
      <script>
      
          ASSET_PREFIX = "";
          SCRIPT_PREFIX = "";
          SCENE_PATH = "460569.json";
          CONTEXT_OPTIONS = {
              'antialias': true,
              'alpha': false,
              'preserveDrawingBuffer': false
          };
          SCRIPTS = [];
          CONFIG_FILENAME = "";
      
      
          var app = new pc2d.Application(document.getElementById("app"),{
              assetPrefix: window.ASSET_PREFIX || "",
              scriptPrefix: window.SCRIPT_PREFIX || "",
              scriptsOrder:window.SCRIPTS || []
          });
      
          var _sync = pc2d.Entity.prototype._sync;
          pc2d.Entity.prototype._sync = function () {
              var _defer = false;
      
      
              if( (this.root !== this) || !(this.root.name === "Untitled" &&  this.root._parent == null)){
                  this.dom = this.dom || document.createElement("div");           
                  this.dom.className = this.tags.list().join(" ");
                  if(this.name !== "New Entity" && this.name !== "Untitled") this.dom.classList.add(this.name);
      
                  if(this.dom.getAttribute("data-pc2d-asset-texture")){
                      var asset = editor.call("assets:get",this.dom.getAttribute("data-pc2d-asset-texture"));
                      if(this.css && this.css.type === "image"){
                          asset && this.dom.setAttribute("src",asset.get("file.url"));
                      }else{
                          this.dom.style.backgroundImage = "url(" + asset.get("file.url") + ")";
                      }             
                  }else{
                      this.dom.removeAttribute("src");
                      if(this.css){
                          this.dom.style.backgroundImage = "";
                      }               
                  }
                  if((this.dom && this.parent) && !this.dom.parentNode && (this.dom.parentNode !== this.parent.dom)){
                      if(this.parent.dom){
                        this.parent.dom.appendChild(this.dom);
                      }             
                  } 
                  
                  if (!this.enabled && !this.css) {
                     this.dom && (this.dom.style.display = "none");
                  }
              }
      
              if(!_defer){
                  return _sync.call(this);
              }
      
              
          }
      
      
      
      
          var response = {
              "application_properties":{
                  fill_mode: "KEEP_ASPECT",
                  height: 1280,
                  libraries: [],
                  loading_screen_script: null,
                  preserve_drawing_buffer: false,
                  resolution_mode: "FIXED",
                  scripts: [],
                  transparent_canvas: false,
                  use_device_pixel_ratio: false,
                  use_legacy_scripts: false,
                  width: 720
              },
              assets:[
      
              ]
          };
          
      
      
          var props = response.application_properties;
          var scenes = response.scenes;
          var assets = response.assets;
      
          var query = location.href.getQuery();
          var projectId = query.projectId;
          var scenehandler = app.loader.getHandler("scene");
          var scenePromise = localforage.getItem("TWCacheEntities/" + projectId);
         function _loadedScenes(callback) {
      
   
              scenePromise.then(function(data){
                  var url = "scene";
                  app.systems.script.preloading = true;
                  var scene = scenehandler.open(url, data);
                  try{
                    
                  }catch(e){
                    // pc2d.TemplateUtils.waitForTemplatesInScene(
                    //     data,
                    //     assets,
                    //     function(data){
                    //       debugger

                    //     });
                  }
                  app.systems.script.preloading = false;
      
                  app.loader.clearCache(url, "scene");
      
                  app.loader.patch({
                     resource: scene,
                     type: "scene"
                  }, app.assets);
      
                  app.root.addChild(scene.root);
      
              
                  if (callback) {
                     callback(null, scene);
                  }
      
              });
          };
      
          function blobToDataURL(blob, callback) {
              let a = new FileReader();
              a.onload = function (e) { callback(e.target.result); }
              a.readAsDataURL(blob);
          }
      
          function _loadAssets(){
              var filelistPromise = localforage.getItem("TWCacheFiles/" + projectId + "/FileList");
              return Promise.all([filelistPromise]).then(([filelist]) => {
                  var assetslist = filelist.map(filename => {
                      return filename.replace("TWCacheFiles/" + projectId + "/", "");
                  });
      
                  var assetsmeta = {};
      
                  var assets = {};
      
                  var assetsPromise = filelist.map(filename => {
                      return localforage.getItem(filename).then(asset => {
      
                          return new Promise(function(resolve){
                            if (asset.file instanceof Blob) {
                              blobToDataURL(asset.file, function (fileurl) {
                                var file = {
                                  filename: asset.file.name, hash: undefined, size: asset.file.size, url: fileurl,
                                };
                                asset.file = file;
                                assets[asset.id] = asset;
                                resolve(asset);
                              })
                            } else {
                              if (asset.type !== "folder") {
                                assets[asset.id] = asset;
                              }
                              resolve(asset);
                            }
                         
                          })
                      })
                  });
      
                  return Promise.all(assetsPromise).then(_ => {
                      return assets;
      
                  });
              })
          }
      
      
      
         
      
          app._parseApplicationProperties(props, function (err) {
             
              _loadAssets().then(function(assets){
                  app._parseAssets(assets);
                  app.preload(function (err) {
                      if (err) {
                          console.error(err);
                      }
      
                      _loadedScenes(function (err, scene) {
                          if (err) {
                              console.error(err);
                          }
                          app.autoRender = false;
                          app.start();
                          app.render();
                      });
                  });
              });
          });
             
      
      
      
      
      
        
      
          // var entity = new pc2d.Entity();
          // app.root.addChild(entity);
          
          // var Video = pc2d.createScript('video');
          // Video.prototype.initialize = function (dt) {
          //     console.log("initialize entity");
          //     this.checkCanAutoPlay = true;
          //     this.video = document.createElement('video');
          //     this.video.setAttribute("name","videoElement");
      
          
          //     this.video.setAttribute("style","width:100%; height:100%"); 
          //     this.video.innerHTML = "Your browser is too old which doesn't support HTML5 video.";
      
          //     this.app.on("postrender",() => {
          //         this.entity.dom.appendChild(this.video);
          //     })
          //     this.app.on("visibilityHidden",() => {
      
          //        // this.flv_pause(); 
          //     });
          //     this.app.on("visibilityVisible",() => {
      
          //        // this.flv_start(); 
          //     });
      
          //     var asset0 = new pc2d.Asset("flv.js","script",{
          //       url: "https://s.ssl.qhimg.com/pkg/serviceplatform/FLVJS_v1.0.1.js?t=3"
          //     });
          //     this.app.assets.add(asset0);
          //     asset0.ready(function(asset){
          //         var mediaDataSource = {
          //             type: 'flv',
          //             url: 'http://img.ksbbs.com/asset/Mon_1704/15868902d399b87.flv',
          //         };
          //         this.flv_load_mds(mediaDataSource);
          //     },this);
          //     this.app.assets.load(asset0);
          // };
          // Video.prototype.flv_load_mds = function(mediaDataSource){
      
          //     var player = this.player;
                  
          //     if (typeof player !== "undefined") {
          //         if (player != null) {
          //             player.unload();
          //             player.detachMediaElement();
          //             player.destroy();
          //             player = null;
          //         }
          //     }
          //     this.player = flvjs.createPlayer(mediaDataSource, {
          //             isLive: false,
          //             autoplay: true,
          //             enableWorker: true,
          //             lazyLoadMaxDuration: 1,
          //             seekType: 'range',
          //             fixAudioTimestampGap: false,
          //             enableStashBuffer: false,
          //             autoCleanupMaxBackwardDuration: 60,
          //             autoCleanupMinBackwardDuration: 30,
          //             statisticsInfoReportInterval: 2000,
          //             stashInitialSize: 128,
      
          //             // 如果是Android浏览器，建议enableDurationMonitor设置为false
          //             enableDurationMonitor: true,    // true表示监测当前直播流延时，当发现延时过大时，主动追赶
          //             enableVideoFrozenMonitor: true, // 监测视频解码是否停滞（画面卡停），当因为某些原因导致无法解码时，将上报VIDEO_FROZEN事件，收到后建议重拉流
          //             videoStateMonitorInterval: 1000, // 多长时间（毫秒）检查一次视频状态（延时、停滞）
      
          //             // 针对手机浏览器上对MSE以及网络连接更加容易不稳定，建议将maxDurationGap设置高一点，比如2.5、3、3.5，否则可能会频繁追赶延时导致画面卡顿
          //             maxDurationGap: 0.5,         // 当前播放位置与缓冲区末尾的距离（秒）如果超过这个值，就触发一次追赶，不易过短
          //             decreaseDurationStep: 0.4,   // 每次追赶至缓冲区末尾之前的多少秒
          //             frozenTimesThreshold: 5,        // 解码停滞次数达到此阈值，上报VIDEO_FROZEN事件。注意如果设置过小的阈值，当推流端关闭摄像头后可能会频繁触发VIDEO_FROZEN事件
      
          //             // webrtc合流未能给cdn推送正确的视频分辨率信息，导致从MetaData/AVCDecoderConfigurationRecord中无法拿到正确的视频分辨率
          //             // 在内核低于Chromium 70的浏览器（如360浏览器、搜狗浏览器、PC微信内嵌浏览器等）中
          //             // 如果传递不对的视频分辨率，将会导致画面放大显示异常，因此，强行设置一个最大的视频宽高信息，来避免此问题
          //             // 如果是Safari浏览器，enableConstVideoViewSize建议设置为false
          //             enableConstVideoViewSize: true,
          //             // constVideoViewWidth: 1920,
          //             // constVideoViewHeight: 1080,
          //     });
          //     player = this.player;
          //         player.on(flvjs.Events.METADATA_ARRIVED, () => {
          //             console.log('--== meta data arrived ==--');
          //         });
      
          //         // player.enableVideoStateMonitor(true or false);   // 如果需要，可以动态开关{视频延时 + 解码停滞}监测
      
          //         // 当收到以下事件时：
          //         // MEDIA_SOURCE_ENDED [流结束]
          //         // MEDIA_SOURCE_CLOSE [流关闭]
          //         // VIDEO_FROZEN [视频解码停滞]
          //         // VIDEO_RESOLUTION_CHANGED [视频分辨率变化]
          //         // ERROR [网络或媒体流错误]
          //         // 建议结合业务信令来判断应该如何处理
          //         // 如果已知推流主动停止，则不必处理，否则建议重拉流
      
          //         //receive different video resolution from AVCSpecificConfig
          //         player.on(flvjs.Events.VIDEO_RESOLUTION_CHANGED, () => {
          //             console.log('--== video resolution changed, reload ==--');
          //            // this.saveSettings();
          //             this.flv_destroy();
          //             this.flv_load_mds(mediaDataSource);
          //         });
          //         player.on(flvjs.Events.MEDIA_SOURCE_ENDED, () => {
          //             console.log('--== media source ended, normally means server stop push stream ==--');
          //             this.flv_destroy();
          //             this.flv_load_mds(mediaDataSource);
          //         });
          //         player.on(flvjs.Events.MEDIA_SOURCE_CLOSE, () => {
          //             console.log('--== media source close, show no source view ==--');
          //         });
          //         player.on(flvjs.Events.VIDEO_FROZEN, () => {
          //             // console.log('--== video frozen ==--');
          //             // flv_load();
          //         });
          //         // see flv.js {api.md}, for example:
          //         // ErrorType: NetworkError
          //         // ErrorDetail: Exception, HttpStatusCodeInvalid, ConnectingTimeout, EarlyEof, UnrecoverableEarlyEof
          //         // ErrorType: MediaError
          //         // ErrorDetail : MediaMSEError
          //         player.on(flvjs.Events.ERROR, (errType, errDetail) => {
          //             console.log('--== flvjs error, type:' + errType + ', detail:' + errDetail + ' ==--');
          //             console.log('--== should set a timer(for example, 3 seconds) to reload current flv ==--');
          //             this.flv_destroy();
          //             this.flv_load_mds(mediaDataSource);
          //         });
      
          //         // show statistics information if need
          //         player.on(flvjs.Events.STATISTICS_INFO, (statInfo) => {
          //             // console.log('current speed: ' + 8 * (parseInt(statInfo.speed * 10) / 10) + 'kbps');
          //             // console.log('video bps: ' + statInfo.bps_video.toFixed(2) + ' kbps, audio bitrate: ' + statInfo.bps_audio.toFixed(2) + ' kbps');
          //             // console.log('dropped frames:' + statInfo.droppedFrames);
          //             // console.log('--== decoded frames:' + statInfo.decodedFrames + ' ==--');
          //             // console.log('loader type:' + statInfo.loaderType);
          //             // console.log('total segment count:' + statInfo.totalSegmentCount + ', current segment index:' + statInfo.currentSegmentIndex);
          //         });
      
          //         player.attachMediaElement(this.video);
          //         player.load();
          //     }
      
          // Video.prototype.flv_destroy = function(){
          //     if (!this.player) {
          //         return;
          //     }
          //     // this.player.pause();
          //     // this.player.unload();
          //     // this.player.detachMediaElement();
          //     this.player.destroy();
          //     this.player = null;
          // };
      
          // Video.prototype.flv_start = function() {
          //     this.player && this.player.play();
          // }
          // Video.prototype.flv_pause = function() {
          //     this.player && this.player.pause();
          // }
      
          // Video.prototype.flv_seekto = function(time) {
          //     this.player && (this.player.currentTime = parseFloat(time));
          // }
      
      
          // Video.prototype.update = function (dt) {
      
          //     if(!this.video.playing && this.checkCanAutoPlay){
          //         //this.video.play();
          //        try{
          //           this.flv_start();
                   
          //        }catch(e){
          //           this.checkCanAutoPlay = false;
          //        }
          //     }
             
          // };
          // entity.addComponent('script');
          // entity.script.create('video');
      
      
      
      
          // app.configure(CONFIG_FILENAME, function (err) {
          //     if (err) {
          //         console.error(err);
          //     }
      
          //     // configureCss(app._fillMode, app._width, app._height);
          //     // reflow();
      
          //     // window.addEventListener('resize', reflow, false);
          //     // window.addEventListener('orientationchange', reflow, false);
      
          //     app.preload(function (err) {
          //         if (err) {
          //             console.error(err);
          //         }
      
          //         app.loadScene(SCENE_PATH, function (err, scene) {
          //             if (err) {
          //                 console.error(err);
          //             }
      
          //             app.start();
          //         });
          //     });
          // });
      </script>
      </body>
</html>





